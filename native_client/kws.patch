diff --git a/native_client/ctcdecode/ctc_beam_search_decoder.cpp b/native_client/ctcdecode/ctc_beam_search_decoder.cpp
index 7ec00f2f..2fa13901 100644
--- a/native_client/ctcdecode/ctc_beam_search_decoder.cpp
+++ b/native_client/ctcdecode/ctc_beam_search_decoder.cpp
@@ -198,7 +198,7 @@ DecoderState::decode() const
   // return order of decoding result. To delete when decoder gets stable.
   for (size_t i = 0; i < num_returned; ++i) {
     Output output;
-    prefixes_copy[i]->get_path_vec(output.tokens, output.timesteps);
+    prefixes_copy[i]->get_path_vec(output.tokens, output.timesteps, output.log_probs);
     double approx_ctc = scores[prefixes_copy[i]];
     if (ext_scorer_ != nullptr) {
       auto words = ext_scorer_->split_labels_into_scored_units(output.tokens);
diff --git a/native_client/ctcdecode/output.h b/native_client/ctcdecode/output.h
index 10eb4228..32257781 100644
--- a/native_client/ctcdecode/output.h
+++ b/native_client/ctcdecode/output.h
@@ -10,6 +10,7 @@ struct Output {
     double confidence;
     std::vector<int> tokens;
     std::vector<int> timesteps;
+    std::vector<float> log_probs;
 };
 
 #endif  // OUTPUT_H_
diff --git a/native_client/ctcdecode/path_trie.cpp b/native_client/ctcdecode/path_trie.cpp
index 749b5a31..8e73040f 100644
--- a/native_client/ctcdecode/path_trie.cpp
+++ b/native_client/ctcdecode/path_trie.cpp
@@ -111,15 +111,16 @@ PathTrie* PathTrie::get_path_trie(int new_char, int new_timestep, float cur_log_
   }
 }
 
-void PathTrie::get_path_vec(std::vector<int>& output, std::vector<int>& timesteps) {
+void PathTrie::get_path_vec(std::vector<int>& output, std::vector<int>& timesteps, std::vector<float>& log_probs) {
   // Recursive call: recurse back until stop condition, then append data in
   // correct order as we walk back down the stack in the lines below.
   if (parent != nullptr) {
-    parent->get_path_vec(output, timesteps);
+    parent->get_path_vec(output, timesteps, log_probs);
   }
   if (character != ROOT_) {
     output.push_back(character);
     timesteps.push_back(timestep);
+    log_probs.push_back(log_prob_c);
   }
 }
 
@@ -241,6 +242,10 @@ void PathTrie::print(const Alphabet& a) {
   for (PathTrie* el : chain) {
     printf("%d ", el->timestep);
   }
+  printf("\nnprobs:\t ");
+  for (PathTrie* el : chain) {
+    printf("%d ", el->log_probs);
+  }
   printf("\n");
   printf("transcript:\t %s\n", tr.c_str());
 }
diff --git a/native_client/ctcdecode/path_trie.h b/native_client/ctcdecode/path_trie.h
index e087b1a6..8e8d2268 100644
--- a/native_client/ctcdecode/path_trie.h
+++ b/native_client/ctcdecode/path_trie.h
@@ -27,7 +27,7 @@ public:
   PathTrie* get_path_trie(int new_char, int new_timestep, float log_prob_c, bool reset = true);
 
   // get the prefix data in correct time order from root to current node
-  void get_path_vec(std::vector<int>& output, std::vector<int>& timesteps);
+  void get_path_vec(std::vector<int>& output, std::vector<int>& timesteps, std::vector<float>& log_probs);
 
   // get the prefix data in correct time order from beginning of last grapheme to current node
   PathTrie* get_prev_grapheme(std::vector<int>& output,
